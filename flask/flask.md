##### 1.Flask 依赖 Jinja 模板引擎和 Werkzeug WSGI 套件。

Werkzeug 用于实现 WSGI ，应用和服务之间的标准 Python 接口。

##### 2.在 Flask 中 由全局对象 request 来提供请求信息。如果您有一些 Python 基础，那么可能 会奇怪：既然这个对象是全局的，怎么还能保持线程安全？  
答案 是本地环境：

##### 3.什么是Blueprint？  
是一种组织一组相关视图和其他代码的方式。与其将视图和其他代码直接注册到应用程序，不如将它们注册到蓝图。然后蓝图在工厂函数中可用时向应用程序注册。
Blueprint是一种组织一组相关视图和其他代码的方式。与其将视图和其他代码直接注册到应用程序，不如将它们注册到蓝图。  
然后蓝图在工厂函数中可用时向应用程序注册。 使用蓝图进行应用模块化。

##### 4.回调和错误

Flask 会在多个阶段调度请求，这会影响请求，响应以及如何处理错误。情境在所有 这些阶段都处于活动状态。

Blueprint 可以为该蓝图的事件添加处理器，处理器会在蓝图与请求路由 匹配的情况下运行。

在每次请求之前， before_request() 函数都会被调用。如果其 中一个函数返回了一个值，则其他函数将被跳过。返回值被视为响应，并且视图 函数不会被调用。

如果 before_request() 函数没有返回响应，则调用匹配路由的 视图函数并返回响应。

视图的返回值被转换为实际的响应对象并传递给 after_request() 函数。每个函数都返回一个修改过的或新的响应对象。

返回响应后，将弹出情境，该情境调用 teardown_request() 和 teardown_appcontext() 函数。即使在上面任何一处引发了未处 理的异常，也会调用这些函数。

如果在拆卸函数之前引发了异常， Flask 会尝试将它与 errorhandler() 函数进行匹配，以处理异常并返回响应。如果找不到 错误处理器，或者处理器本身引发异常， Flask 将返回一个通用的 500 Internal Server Error 响应。拆卸函数仍然被调用，并传递异常对象。

如果开启了调试模式，则未处理的异常不会转换为 500 响应，而是会传播到 WSGI 服务器。这允许开发服务器向交互式调试器提供回溯。

##### 5. 装饰器的作用？@wraps(func)作用？
装饰器：在不改变原有代码的基础上，增加额外的功能。例如是否登录，是否有权限等。
@wraps(func):不改变使用装饰器的原有函数的结构(__name__,__doc__)

##### 6.python内置类属性？
__name__: 用于判断当前模块是不是程序的入口，如果当前程序正在使用，则值是__main__  
__doc__: 用于描述该对象的作用  
__dict__: 类的属性（包含一个字典，由类的属性组成）  
__moudle__: 类定义所在的模块  
__bases__: 类的所有父类构成的元素  
__main__: 返回的是本模块

##### 7.一条mysql查询语句是如何执行的？
大体来说，Mysql可以分为Server层和存储引擎层两部分。
存储引擎层：存储数据，提供读写接口。其架构模式是插件式的，支持Innodb,Myisam,Memory等多个存储引擎。   
Server层：
        连接器：连接器负责跟客户端建立连接、获取权限、维持和管理连接。
             数据库里面长连接：连接成功后，如果客户端持续有请求，则一直使用同一个连接。  
             数据库里面短链接： 则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。  
             建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是  
             尽量使用长连接。  
        查询缓存：命中则直接返回结果 
            MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。
            之前执行过的语句及其结果可能会以key-value对的形式，被直缓存在内存中。
            key是查询的语句，value是查询的结果。
            如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。  
        分析器：
             词法分析：需要对SQL语句做解析，识别字符串。
             语法分析：根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。
        优化器： 
             经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。
             优化器是在表里面有多个索引的时候，决定使用哪个索引；
             或者在一个语句有多表关联join的时候，决定各个表的连接顺序。
        执行器： 
            MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，
            开始执行语句。开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，
            如果没有，就会返回没有权限的错误，如下所示。如果有权限，就打开表继续执行。
            打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
            比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：
            1.调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，
            如果是则将这行存在结果集中；
            2.调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
            3.执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
            至此，这个语句就执行完成了。
            你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。
            这个值就是在执行器每次调用引擎获取数据行的时候累加的。

##### 7.一条mysql更新语句是如何执行的？  
redo log （ 重做日志）InnoDB 引擎特有的日志。
binlog （ 归档日志）  Server 层也有自己的日志。
MySQL里经常说到的WAL技术，WAL的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。  
具体来说， 当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存【？】，这个时候更新就算完成了。
同时， InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。
不同：  
    1.redo log是Innodb引擎特有的，binlog是Server层的日志，所有引擎都可以使用。  
    2.redo log是物理日志，记录的是在某个数据页上做了什么修改。  
      而binlog是逻辑日志，记录的是这个语句的原始语句，比如给“id=2这一行的C字段加1”  
    3.redo log是循环写的，空间固定会用完。  
      binlog是可以追加写入的。“追加写”binlog写入到一定大小后会切换下一个，并不会覆盖以前的日志。  
    
1.执行器先找引擎取ID=2这一行，ID是主键，引擎直接用B+树搜索到这一行，如果ID=2所在行的这页数据本来就在内存中，  
就直接返回给执行器。否则需要从磁盘读取到内存，再返回给执行器。  
2.执行器拿到引擎给的行数据，把这个值加上1，得到新的一行数据，再调用引擎接口，写入新的一行数据。  
3.引擎将这行数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。  
然后告知执行器执行完成了，随时可以提交事物。  
4.执行器生成这个操作的binlog，并把binlog写入到磁盘中。  
5.执行器调用引擎的提交事物接口，引擎把刚刚写入的redo log改成Commit状态，更新完成。

##### 8.怎样让数据库恢复到半个月内任意一秒的状态？  
前面我们说过了，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。
如果你的DBA承诺说半个月内可以恢复，
那么备份系统中一定会保存最近半个月的所有binlog，
同时系统会定期做整库备份。这里的“定期”
取决于系统的重要性，可以是一天一备，也可以是一周一备。
当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，
需要找回数据，那你可以这么做：首先，
找到最近的一次全量备份，如果你运气好，
可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
然后，从备份的时间点开始，将备份的binlog依次取出来，
重放到中午误删表之前的那个时刻。这样你的临时库就跟误删之前的线上库一样了，
然后你可以把表数据从临时库取出来，按需要恢复到线上库去。  

##### 9.为什么要有两阶段提交？
这是为了让两份日志之间的逻辑一致。  

##### 10.
把内存里的数据写入磁盘的过程，术语就是flush 。  

##### 11.一条SQL语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。 看上去，这就像是数据库“抖”了一下。
当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。
内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。
平时执行很快的更新操作，其实就是在写内存和日志，
而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。  

##### 12.InnoDB刷脏页的控制策略？  
要用到innodb_io_capacity 这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设置成磁盘的
IOPS。 磁盘的IOPS可以通过fio这个工具来测试。  
要尽量避免这种情况，你就要合理地设置innodb_io_capacity的值，
并且平时要多关注脏页比例，不要让它经常接近75%。
其中，脏页比例是通过Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total得到的。  

一旦一个查询请求需要在执行过程中先flush掉一个脏页时，
这个查询就可能要比平时慢了。而MySQL中的一个机制，可能让你的查询会更慢：
在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；
而且这个把“邻居”拖下水的逻辑还可以继续蔓延，
也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，
也会被放到一起刷。在InnoDB中，innodb_flush_neighbors参数就是用来控制这个行为的，
值为1的时候会有上述的“连坐”机制，值为0时表示不找邻居，自己刷自己的。找“邻居”这个优化在机械硬盘时代是很有意义的，
可以减少很多随机IO。
机械硬盘的随机IOPS一般只有几百，相同的逻辑操作减少随机IO就意味着系统性能的大幅度提升。
而如果使用的是SSD这类IOPS比较高的设备的话，
我就建议你把innodb_flush_neighbors的值设置成0。
因为这时候IOPS往往不是瓶颈，而“只刷自己”就能更快地执行完必要的刷脏页操
作，减少SQL语句响应时间。在MySQL8.0中，innodb_flush_neighbors参数的默认值已经是0了。

##### 13.为什么表数据删掉一半，表文件大小不变？  
delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。
也就是说，通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，
看起来就像是“空洞”。实际上，不止是删除数据会造成空洞，插入数据也会。
如果数据是按照索引递增顺序插入的，那么索引是紧凑的。
但如果数据是随机插入的，就可能造成索引的数据页分裂。  

##### 14.select city,name,age from t where city='杭州'order by  name limit 1000;这个语句看上去逻辑很清晰，但是你了解它的执行流程吗？今天，我就和你聊聊这个语句是怎么执行的，以及有什么参数会影响执行的行为。
sort_buffer：MySQL会给每个线程分配一块内存用于排序， 称为sort_buffer
通常情况下，
这个语句执行流程如下所示：
1.初始化sort_buffer，确定放入name、city、age这三个字段；
2.从索引city找到第一个满足city='杭州’条件的主键id，也就是图中的ID_X；
3.到主键id索引取出整行，取name、city、age三个字段的值，存入sort_buffer中；
4.从索引city取下一个记录的主键id；
5.重复步骤3、4直到city的值不满足查询条件为止，对应的主键id也就是图中的ID_Y；
6.对sort_buffer中的数据按照字段name做快速排序；
7.按照排序结果取前1000行返回给客户端。
我们暂且把这个排序过程，称为全字段排序。  









